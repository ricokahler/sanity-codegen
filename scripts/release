#!/usr/bin/env node
const { promisify } = require('util');
const exec = promisify(require('child_process').exec);
const { stripIndents } = require('common-tags');
const semver = require('semver');
const fetch = require('node-fetch').default;
const fs = require('fs');
const path = require('path');

const bumpTypes = {
  3: 'major',
  2: 'minor',
  1: 'patch',
};

const getScore = ({ type, breaking }) => {
  if (breaking) return 3;
  if (type === 'feat') return 2;
  if (type === 'fix') return 1;
  if (type === 'pref') return 1;
  return 0;
};

const getMessage = ({ scope, message, hash }) =>
  `- ${scope ? `**${scope}**: ` : ''}${message} ${hash.substring(0, 7)}`;

async function analyzeCommits() {
  const { stdout } = await exec(
    'git log $(git describe --tags --abbrev=0)..HEAD --pretty=oneline'
  );

  const parsedLines = (
    await Promise.all(
      stdout
        .split('\n')
        .filter(Boolean)
        .map(async (line) => {
          const match = /(\w+)(?:\((\w+)\))?:\s(.+)/.exec(line);
          if (!match) return null;

          const [, type, scope, message] = match;

          const hash = line.substring(0, 40);
          const { stdout } = await exec(`git log --format=%B -n 1 ${hash}`);
          const fullMessage = stdout.split('\n').slice(1).join('\n').trim();
          const breaking = /breaking\s+change/i.test(fullMessage);
          const forcedVersionMatch = /force version: (.+)/i.exec(stdout);
          const forcedVersion = forcedVersionMatch && forcedVersionMatch[1];

          return {
            hash,
            type: type.toLowerCase(),
            scope: scope?.toLowerCase(),
            message: message?.trim(),
            breaking,
            fullMessage,
            forcedVersion,
          };
        })
    )
  )
    .filter(Boolean)
    .map((parsed) => ({ ...parsed, score: getScore(parsed) }));

  const forcedVersion = parsedLines.reverse().find((i) => i.forcedVersion)
    ?.forcedVersion;

  const max = parsedLines
    .map((i) => i.score)
    .reduce((max, next) => (next > max ? next : max), 0);

  const { feat, fix, perf } = parsedLines.reduce((acc, next) => {
    const arr = acc[next.type] || [];
    arr.push(next);
    acc[next.type] = arr;
    return acc;
  }, {});

  const breakingChangesMessages = parsedLines
    .filter((i) => i.breaking)
    .map((i) => i.fullMessage)
    .join('\n\n');

  const breakingChanges =
    breakingChangesMessages &&
    stripIndents`
      ## Breaking Changes ðŸ˜…

      ${breakingChangesMessages}
    `;

  const bumpType = bumpTypes[max];
  if (!bumpType) return null;

  const features =
    feat &&
    stripIndents`
      ## Features âœ¨
      
      ${feat.map(getMessage).join('\n')}
    `;

  const bugFixes =
    fix &&
    stripIndents`
      ## Bug Fixes ðŸ›
      
      ${fix.map(getMessage).join('\n')}
    `;

  const performance =
    perf &&
    stripIndents`
      ## Performance ðŸš€
      
      ${perf.map(getMessage).join('\n')}
    `;

  const { stdout: currentVersion } = await exec(
    'git describe --tags --abbrev=0'
  );

  // TODO: uncomment when out of alpha
  const nextVersion =
    forcedVersion || semver.inc(currentVersion, /* bumpType */ 'prerelease');

  const changelog = stripIndents`
    # v${nextVersion}
    ${breakingChanges ? `${breakingChanges}\n` : ''}
    ${features ? `${features}\n` : ''}
    ${bugFixes ? `${bugFixes}\n` : ''}
    ${performance ? `${performance}\n` : ''}
  `;

  return { changelog, nextVersion };
}

async function main() {
  const packages = await fs.promises.readdir(
    path.resolve(__dirname, '../packages')
  );

  // build
  console.log('Buildingâ€¦');
  const { stdout: buildOutput } = await exec('npm run build');
  console.log(buildOutput);

  const result = await analyzeCommits();
  if (!result) return;

  const { changelog, nextVersion } = result;

  // update package-jsons
  for (const p of packages) {
    const buffer = await fs.promises.readFile(
      path.resolve(__dirname, `../packages/${p}/package.json`)
    );
    const packageJson = JSON.parse(buffer.toString());

    await fs.promises.writeFile(
      path.resolve(__dirname, `../packages/${p}/package.json`),
      `${JSON.stringify(
        {
          ...packageJson,
          version: nextVersion,
          ...(packageJson.selfDependencies && {
            dependencies: {
              ...packageJson.dependencies,
              ...packageJson.selfDependencies.reduce((acc, next) => {
                acc[next] = nextVersion;
                return acc;
              }, {}),
            },
          }),
        },
        null,
        2
      )}\n`
    );
  }

  // publish new versions to NPM
  for (const p of packages) {
    await fs.promises.writeFile(
      path.resolve(__dirname, `../packages/${p}/.npmrc`),
      `//registry.npmjs.org/:_authToken=${process.env.NPM_TOKEN}`
    );
    const { stdout } = await exec('npm publish --access public --tag alpha', {
      cwd: path.resolve(__dirname, `../packages/${p}`),
    });

    console.log(stdout);
  }

  // publish release to github via API
  await fetch(
    'https://api.github.com/repos/ricokahler/sanity-codegen/releases',
    {
      method: 'POST',
      headers: {
        accept: 'application/json',
        authorization: `Basic ${Buffer.from(
          `ricokahler:${process.env.GITHUB_TOKEN}`
        ).toString('base64')}`,
        'content-type': 'application/json',
      },
      body: JSON.stringify({
        name: `v${nextVersion}`,
        tag_name: `v${nextVersion}`,
        target_commitish: 'alpha',
        body: changelog,
        prerelease: true,
      }),
    }
  );
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
